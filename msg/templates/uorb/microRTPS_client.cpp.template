@###############################################
@#
@# EmPy template for generating <msg>_uRTPS_UART.cpp file
@#
@###############################################
@# Start of Template
@#
@# Context:
@#  - msgs (List) list of all msg files
@#  - multi_topics (List) list of all multi-topic names
@###############################################
@{
import genmsg.msgs
import gencpp
from px_generate_uorb_topic_helper import * # this is in Tools/
from px_generate_uorb_topic_files import MsgScope # this is in Tools/
from message_id import * # this is in Tools/

topic_names = [single_spec.short_name for single_spec in spec]
send_topics = [s.short_name for idx, s in enumerate(spec) if scope[idx] == MsgScope.SEND]
recv_topics = [s.short_name for idx, s in enumerate(spec) if scope[idx] == MsgScope.RECEIVE]

}@
#include <px4_config.h>
#include <px4_tasks.h>
#include <px4_posix.h>
#include <unistd.h>
#include <stdio.h>
#include <poll.h>
#include <string.h>
#include <termios.h>
#include <ctime>

#include <microcdr/microCdr.h>
#include <uORB/uORB.h>

#include "UART_node.h"

@[for topic in list(set(topic_names))]@
#include <uORB/topics/@(topic).h>
@[end for]@

#define BUFFER_SIZE 1024
#define POLL_TIME_MS 0
#define UPDATE_TIME_MS 0
#define LOOPS 10000
#define USLEEP_MS 0
#define BAUDRATE 460800
#define DEVICE "/dev/ttyACM0"

@[if recv_topics]@
void *uart_reader_thread(void *data);
@[end if]@

extern "C" __EXPORT int micrortps_client_main(int argc, char *argv[]);

static bool _should_exit_task = false;
static uint32_t _received = 0;

@[if recv_topics]@
struct reader_data {
    int uart_fd;
    UART_node &uart_node;
@[for topic in recv_topics]@
        orb_advert_t @(topic)_pub;
@[end for]@
};

void *uart_reader_thread(void *data)
{
    struct reader_data *reader_data = (struct reader_data *)data;

    // We poll on UART, so we can use protocol splitter driver
    struct pollfd poll_fd[1] = { };
    poll_fd[0].fd = reader_data->uart_fd;
    poll_fd[0].events = POLLIN;

    // microBuffer to deserialize
    char data_buffer[BUFFER_SIZE] = {};
    struct microBuffer microBufferReader;
    initDeserializedAlignedBuffer(data_buffer, BUFFER_SIZE, &microBufferReader);
    // microCDR structs for managing the microBuffer
    struct microCDR microCDRReader;
    initMicroCDR(&microCDRReader, &microBufferReader);

    // TODO maybe a method for each topic handler, so we don't need to
    // declare all these here?
@[for topic in recv_topics]@
    struct @(topic)_s @(topic)_data { };
@[end for]@

    while (!_should_exit_task) {
        int r = poll(poll_fd, 1, 100);
        if (r == 1 && poll_fd[0].revents & POLLIN)
        {
            char topic_ID = 255;
            while (0 < reader_data->uart_node.readFromUART(&topic_ID, data_buffer, BUFFER_SIZE))
            {
                switch (topic_ID)
                {
@[for topic in recv_topics]@
                    case @(message_id(topic)):
                        deserialize_@(topic)(&@(topic)_data, data_buffer, &microCDRReader);
                        orb_publish(ORB_ID(@(topic)), reader_data->@(topic)_pub, &@(topic)_data);
                        //printf("                >>[%d] %llu\n", @(message_id(topic)), @(topic)_data.timestamp);
                        ++_received;
                    break;
@[end for]@
                }
            }
        }
    }

    return nullptr;
}
@[end if]@

int micrortps_client_main(int argc, char *argv[])
{
    // TODO use proper options with getopt here
    const char *device = DEVICE;
    if (argc > 1) device = argv[1];

    int update_time = UPDATE_TIME_MS;
    if (argc > 2) update_time = atoi(argv[2]);

    int poll_time = POLL_TIME_MS;
    if (argc > 3) poll_time = atoi(argv[3]);

    int loops = LOOPS;
    if (argc > 4) loops = atoi(argv[4]);

    int usleep_ms = USLEEP_MS;
    if (argc > 5) usleep_ms = atoi(argv[5]);

    uint32_t baudrate = BAUDRATE;
    if (argc > 6) baudrate = atoi(argv[6]);

    printf("device: %s update: %dms poll: %dms loops: %d usleep_ms: %d baudrate: %d\n", device, update_time, poll_time, loops, usleep_ms, baudrate);
    usleep(2000000);

    int uart_fd;
    UART_node m_uartNode;
    if ((uart_fd = m_uartNode.init_uart(device, baudrate)) < 0)
    {
        printf("ERROR UART INIT, EXITING...\n");
        return -1;
    }

    char data_buffer[BUFFER_SIZE] = {};
@[if send_topics]@

    /* subscribe to topics */
    int fds[@(len(send_topics))];

    // orb_set_interval statblish an update interval period in milliseconds.
@[for idx, topic in enumerate(send_topics)]@
    fds[@(idx)] = orb_subscribe(ORB_ID(@(topic)));
    orb_set_interval(fds[@(idx)], update_time);
@[end for]@
@[end if]@

@[if recv_topics]@
    pthread_t _reader_thread{};

    /* advertise topics */
@[for topic in recv_topics]@
    struct @(topic)_s @(topic)_data { };
    orb_advert_t @(topic)_pub = orb_advertise(ORB_ID(@(topic)), &@(topic)_data);
@[end for]@
@[end if]@
@[if send_topics]@

    // microBuffer to serialized using the user defined buffer
    struct microBuffer microBufferWriter;
    initStaticAlignedBuffer(data_buffer, BUFFER_SIZE, &microBufferWriter);
    // microCDR structs for managing the microBuffer
    struct microCDR microCDRWriter;
    initMicroCDR(&microCDRWriter, &microBufferWriter);
@[end if]@
@[if recv_topics]@

    /* Set up and start receiver thread */
    pthread_attr_t reader_attr;

    struct sched_param param;
    (void)pthread_attr_getschedparam(&reader_attr, &param);
    param.sched_priority = SCHED_PRIORITY_MAX - 80;
    (void)pthread_attr_setschedparam(&reader_attr, &param);

    pthread_attr_init(&reader_attr);
    pthread_attr_setstacksize(&reader_attr, PX4_STACK_ADJUSTED(2100));

    struct reader_data reader_data {
        .uart_fd = uart_fd,
        .uart_node = m_uartNode,
@[for topic in recv_topics]@
        .@(topic)_pub = @(topic)_pub,
@[end for]@
    };
    pthread_create(&_reader_thread, &reader_attr, uart_reader_thread, &reader_data);
@[end if]@

@[if send_topics]@
    uint32_t length = 0;
@[end if]@
    uint32_t sent = 0;
    uint64_t total_send_lenght = 0;

    struct timespec begin;
    clock_gettime(0, &begin);
    int i = 0;
    while (!_should_exit_task)
    {
@[if send_topics]@
        bool updated;
@[for idx, topic in enumerate(send_topics)]@
        orb_check(fds[@(idx)], &updated);
        if (updated)
        {
            // obtained data for the file descriptor
            struct @(topic)_s data;
            // copy raw data into local buffer
            orb_copy(ORB_ID(@(topic)), fds[@(idx)], &data);
            serialize_@(topic)(&data, data_buffer, &length, &microCDRWriter);
            m_uartNode.writeToUART((char)@(message_id(topic)), data_buffer, length);
            //printf("[%d]>> %llu\n", @(message_id(topic)), data.timestamp);
            ++sent;
            total_send_lenght += (length + 9);
        }
@[end for]@
@[end if]@

        usleep(usleep_ms);

        // loop forever if informed loop number is negative
        if (loops > 0 && ++i >= loops)
            _should_exit_task = true;
    }
    pthread_join(_reader_thread, nullptr);

    struct timespec end;
    clock_gettime(0, &end);
    double elapsed_secs2 = double(end.tv_sec - begin.tv_sec) + double(end.tv_nsec - begin.tv_nsec)/double(1000000000);
    printf("\nSENT: %d RECEIVED: %d in %d LOOPS\n%llu bytes in %.03f seconds sent %.02fKB/s\n",
            sent, _received, i, total_send_lenght, elapsed_secs2, (double)total_send_lenght/(1000*elapsed_secs2));

    PX4_INFO("exiting");
    fflush(stdout);
    return 0;
}
