@###############################################
@#
@# EmPy template for generating RtpsTopics.cxx file
@#
@###############################################
@# Start of Template
@#
@# Context:
@#  - msgs (List) list of all msg files
@###############################################
@{
import genmsg.msgs
import gencpp
from px_generate_uorb_topic_helper import * # this is in Tools/
from px_generate_uorb_topic_files import MsgScope # this is in Tools/
from message_id import * # this is in Tools/

topic_names = [single_spec.short_name for single_spec in spec]
send_topics = [s.short_name for idx, s in enumerate(spec) if scope[idx] == MsgScope.SEND]
recv_topics = [s.short_name for idx, s in enumerate(spec) if scope[idx] == MsgScope.RECEIVE]
}@
// Copyright 2017 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "RtpsTopics.h"

bool RtpsTopics::init()
{
@[if recv_topics]@
    // Initialise subscribers
@[for topic in recv_topics]@
    if (_@(topic)_sub.init()) {
        std::cout << "@(topic) subscriber started" << std::endl;
    } else {
        std::cout << "ERROR starting @(topic) subscriber" << std::endl;
        return false;
    }

@[end for]@
@[end if]@
@[if send_topics]@
    // Initialise publishers
@[for topic in send_topics]@
    if (_@(topic)_pub.init()) {
        std::cout << "@(topic) publisher started" << std::endl;
    } else {
        std::cout << "ERROR starting @(topic) publisher" << std::endl;
        return false;
    }

@[end for]@
@[end if]@
    return true;
}

@[if send_topics]@
void RtpsTopics::publish(char topic_ID, char data_buffer[], size_t len)
{
    switch (topic_ID)
    {
@[for topic in send_topics]@
        case @(message_id(topic)): // @(topic)
        {
            //printf("@(topic)\n");
            //printf("buf %s\n", data_buffer);
            @(topic)_ st;
            eprosima::fastcdr::FastBuffer cdrbuffer(data_buffer, len);
            eprosima::fastcdr::Cdr cdr_des(cdrbuffer);
            st.deserialize(cdr_des);
            _@(topic)_pub.publish(&st);
            //printf("                >>[%d] %lu\n", @(message_id(topic)), st.timestamp());
        }
        break;
@[end for]@
        default:
            printf("Unexpected topic ID to publish\n");
        break;
    }
}
@[end if]@
@[if recv_topics]@

bool RtpsTopics::hasMsg(char *topic_ID)
{
    if (nullptr == topic_ID) return false;

    *topic_ID = 0;
    while (_next_sub_idx < @(len(recv_topics)) && 0 == *topic_ID)
    {
        switch (_sub_topics[_next_sub_idx])
        {
@[for topic in recv_topics]@
            case @(message_id(topic)): if (_@(topic)_sub.hasMsg()) *topic_ID = @(message_id(topic)); break;
@[end for]@
            default:
                printf("Unexpected topic ID to check hasMsg\n");
            break;
        }
        _next_sub_idx++;
    }

    if (0 == *topic_ID)
    {
        _next_sub_idx = 0;
        return false;
    }

    return true;
}

bool RtpsTopics::getMsg(const char topic_ID, eprosima::fastcdr::Cdr &scdr)
{
    bool ret = false;
    switch (topic_ID)
    {
@[for topic in recv_topics]@
        case @(message_id(topic)): // @(topic)
            if (_@(topic)_sub.hasMsg())
            {
                @(topic)_ msg = _@(topic)_sub.getMsg();
                msg.serialize(scdr);
                ret = true;
            }
        break;
@[end for]@
        default:
            printf("Unexpected topic ID to getMsg\n");
        break;
    }

    return ret;
}
@[end if]@
