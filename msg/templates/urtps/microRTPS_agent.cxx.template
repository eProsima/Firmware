@###############################################
@#
@# EmPy template for generating <msg>_uRTPS_UART.cpp file
@#
@###############################################
@# Start of Template
@#
@# Context:
@#  - msgs (List) list of all msg files
@#  - multi_topics (List) list of all multi-topic names
@###############################################
@{
import genmsg.msgs
import gencpp
from px_generate_uorb_topic_helper import * # this is in Tools/
from px_generate_uorb_topic_files import MsgScope # this is in Tools/

topic_names = [single_spec.short_name for single_spec in spec]
topic_scopes = scope
}@
// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file sensor_combined_PubSubMain.cpp
 * This file acts as a main entry point to the application.
 *
 * This file was generated by the tool fastcdrgen.
 */

@[for topic in list(set(topic_names))]
#include "@(topic)_Publisher.h"
#include "@(topic)_Subscriber.h"
@[end for]@

#include "UART_node.h"

#include <fastcdr/Cdr.h>
#include <fastcdr/FastCdr.h>
#include <fastcdr/exceptions/Exception.h>
#include <fastrtps/utils/eClock.h>
#include <fastrtps/Domain.h>

#include <unistd.h>

#define BUFFER_SIZE 256
#define USLEEP_MS 2000

using namespace eprosima;
using namespace eprosima::fastrtps;

int main(int argc, char** argv)
{
    UART_node m_uartNode;
    std::string uart = "/dev/ttyACM0";
    if (argc > 1) uart = std::string(argv[1]);
    if (0 != m_uartNode.init_uart(uart.c_str()))
    {
        printf("EXITING...\n");
        return -1;
    }

    int usleep_ms = USLEEP_MS;
    if (argc > 2) usleep_ms = atoi(argv[2]);

    char data_buffer[BUFFER_SIZE] = {};
@[if (MsgScope.SEND in topic_scopes)]@
    char rx_buffer[BUFFER_SIZE] = {};
    uint32_t rx_buff_pos = 0u;
@[end if]@

    // Create subscribers
@[for id, topic in enumerate(topic_names)]@
    @[if (topic_scopes[id] == MsgScope.RECEIVE)]@

    @(topic)_Subscriber @(topic)_sub;
    if (true == @(topic)_sub.init()) std::cout << "@(topic) subscriber created" << std::endl;
    else                             std::cout << "ERROR creating @(topic) subscriber" << std::endl;
    @[end if]@
@[end for]@

    // Create publishers
@[for id, topic in enumerate(topic_names)]@
    @[if (topic_scopes[id] == MsgScope.SEND)]@

    @(topic)_Publisher @(topic)_pub;
    @(topic)_pub.init();
    @[end if]@
@[end for]@

    int received = 0, sent = 0, wait = 0, read = 0, total_read = 0;
    char topic_ID = 255;

    struct timespec begin;
    bool start = true, receiving = false;
    do
    {
        if (!receiving)
        {
            clock_gettime(0, &begin);
        }
@[if (MsgScope.SEND in topic_scopes)]@
        // Publish messages received from UART
        while (0 < (read = m_uartNode.readFromUART(&topic_ID, data_buffer, rx_buffer, rx_buff_pos)))
        {
            switch (topic_ID)
            {
    @[for id, topic in enumerate(topic_names)]@
        @[if (topic_scopes[id] == MsgScope.SEND)]@

                case @(id):
                {
                    @(topic)_ st;
                    eprosima::fastcdr::FastBuffer cdrbuffer(data_buffer, sizeof(data_buffer));
                    eprosima::fastcdr::Cdr cdr_des(cdrbuffer);
                    st.deserialize(cdr_des);
                    @(topic)_pub.publish(&st);
                    //printf("                >>[%d] %lu\n", @(id), st.timestamp());
                    ++received;
                    total_read += read;
                }
                break;
         @[end if]@
    @[end for]@

            }
            receiving = true;
            wait = 0;
        }
@[end if]@

        // Send subscribed topics over UART
@[for id, topic in enumerate(topic_names)]@
    @[if (topic_scopes[id] == MsgScope.RECEIVE)]@

        if (@(topic)_sub.hasMsg())
        {
            @(topic)_ msg = @(topic)_sub.getMsg();
            eprosima::fastcdr::FastBuffer cdrbuffer(data_buffer, sizeof(data_buffer));
            eprosima::fastcdr::Cdr scdr(cdrbuffer);
            msg.serialize(scdr);
            size_t len = scdr.getSerializedDataLength();
            //printf("[%d]>> %lu\n", @(id), msg.timestamp());
            m_uartNode.writeToUART((char) @(id), scdr.getBufferPointer(), len);
            ++sent;
        }
    @[end if]@
@[end for]@

        if (receiving && ++wait > 10)
        {
            struct timespec end;
            clock_gettime(0, &end);
            double elapsed_secs = double(end.tv_sec - begin.tv_sec) + double(end.tv_nsec - begin.tv_nsec)/double(1000000000);
            printf("\nRECEIVED: %d SENT: %d\n%d bytes in %.03f seconds received %.02fKB/s\n",
                    received, sent, total_read, elapsed_secs, (double)total_read/(1000*elapsed_secs));
            received = sent = total_read = wait = 0;
            receiving = false;
        }
        usleep(usleep_ms);
    }while(true);

    return 0;
}
