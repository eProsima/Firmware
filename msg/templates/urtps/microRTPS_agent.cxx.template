@###############################################
@#
@# EmPy template for generating <msg>_uRTPS_UART.cpp file
@#
@###############################################
@# Start of Template
@#
@# Context:
@#  - msgs (List) list of all msg files
@#  - multi_topics (List) list of all multi-topic names
@###############################################
@{
import genmsg.msgs
import gencpp
from px_generate_uorb_topic_helper import * # this is in Tools/
from px_generate_uorb_topic_files import MsgScope # this is in Tools/
from message_id import * # this is in Tools/

topic_names = [single_spec.short_name for single_spec in spec]
send_topics = [s.short_name for idx, s in enumerate(spec) if scope[idx] == MsgScope.SEND]
recv_topics = [s.short_name for idx, s in enumerate(spec) if scope[idx] == MsgScope.RECEIVE]
}@
// Copyright 2017 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file sensor_combined_PubSubMain.cpp
 * This file acts as a main entry point to the application.
 *
 * This file was generated by the tool fastcdrgen.
 */

#include <thread>
#include <unistd.h>
#include <poll.h>
#include <chrono>
#include <ctime>

#include <fastcdr/Cdr.h>
#include <fastcdr/FastCdr.h>
#include <fastcdr/exceptions/Exception.h>
#include <fastrtps/utils/eClock.h>
#include <fastrtps/Domain.h>

#include "microRTPS_transport.h"
#include "RtpsTopics.h"

#define BUFFER_SIZE 1024

// Default values
#define DEVICE "/dev/ttyACM0"
#define SLEEP_US 1
#define BAUDRATE 460800
#define POLL_MS 0
#define WAIT_CNST 2

using namespace eprosima;
using namespace eprosima::fastrtps;

bool running = true;
UART_node uart_node;
RtpsTopics topics;
uint32_t total_sent = 0, sent = 0;

struct options {
    const char *device;
    int sleep_us;
    uint32_t baudrate;
    int poll_ms;
} _options = {
    .device = DEVICE,
    .sleep_us = SLEEP_US,
    .baudrate = BAUDRATE,
    .poll_ms = POLL_MS
};

static void usage(const char *name)
{
    printf("usage: %s [options]\n\n"
             "  -d <device>             UART device. Default /dev/ttyACM0\n"
             "  -s <sleep_time_us>      Time in us for which each iteration sleep. Default 1ms\n"
             "  -b <baudrate>           UART device baudrate. Default 460800\n"
             "  -p <poll_ms>            Time in ms to poll over UART. Default 1ms\n",
             name);
}

static int parse_options(int argc, char **argv)
{
    int ch;

    while ((ch = getopt(argc, argv, "d:s:b:p:")) != EOF)
    {
        switch (ch)
        {
            case 'd': _options.device         = optarg; break;
            case 's': _options.sleep_us       = strtol(optarg, nullptr, 10); break;
            case 'b': _options.baudrate       = strtoul(optarg, nullptr, 10); break;
            case 'p': _options.poll_ms        = strtol(optarg, nullptr, 10); break;
            default:
                usage(argv[0]);
            return -1;
        }
    }

    if (optind < argc)
    {
        usage(argv[0]);
        return -1;
    }

    return 0;
}
@[if recv_topics]@

void t_send(void *data)
{
    char data_buffer[BUFFER_SIZE] = {};
    int length = 0;
    char topic_ID = 255;

    while (running)
    {
        // Send subscribed topics over UART
        while (topics.hasMsg(&topic_ID))
        {
            eprosima::fastcdr::FastBuffer cdrbuffer(data_buffer, sizeof(data_buffer));
            eprosima::fastcdr::Cdr scdr(cdrbuffer);
            if (topics.getMsg(topic_ID, scdr))
            {
                length = scdr.getSerializedDataLength();
                //printf("[%d]>> %lu\n", topic_ID, msg.timestamp());
                if (0 < (length = uart_node.write(topic_ID, scdr.getBufferPointer(), length)))
                {
                    total_sent += length;
                    ++sent;
                }
            }
        }

        usleep(_options.sleep_us);
    }
}
@[end if]@

int main(int argc, char** argv)
{
    int uart_fd = 0;
    if (-1 == parse_options(argc, argv) ||
        (uart_fd = uart_node.init(_options.device, _options.baudrate)) < 0)
    {
        printf("EXITING...\n");
        return -1;
    }

    printf("\ndevice: %s; sleep: %dus; baudrate: %d; poll: %dms\n\n",
           _options.device, _options.sleep_us, _options.baudrate, _options.poll_ms);
    sleep(1);

@[if send_topics]@
    char data_buffer[BUFFER_SIZE] = {};
    int received = 0, loop = 0;
    int length = 0, total_read = 0;
    bool receiving = false;
    char topic_ID = 255;
    std::chrono::time_point<std::chrono::steady_clock> start, end;

    struct pollfd poll_fd[1] = {};
    poll_fd[0].fd = uart_fd;
    poll_fd[0].events = POLLIN;
@[end if]@

    topics.init();

    running = true;
@[if recv_topics]@
    std::thread sender_thread(t_send, nullptr);
@[end if]@

    while (running)
    {
@[if send_topics]@
        ++loop;
        int r = poll(poll_fd, 1, _options.poll_ms);
        if (!receiving) start = std::chrono::steady_clock::now();
        if (r == 1 && (poll_fd[0].revents & POLLIN))
        {
            // Publish messages received from UART
            while (0 < (length = uart_node.read(&topic_ID, data_buffer, BUFFER_SIZE)))
            {
                topics.publish(topic_ID, data_buffer, sizeof(data_buffer));
                ++received;
                total_read += length;
                receiving = true;
                end = std::chrono::steady_clock::now();
            }
        }

        if (receiving && std::chrono::duration<double>(std::chrono::steady_clock::now() - end).count() > WAIT_CNST)
        {
            std::chrono::duration<double>  elapsed_secs = end - start;
            printf("\nSENT:     %lu messages - %lu bytes\n",
                    (unsigned long)sent, (unsigned long)total_sent);
            printf("RECEIVED: %d messages - %d bytes; %d LOOPS - %.03f seconds - %.02fKB/s\n\n",
                    received, total_read, loop, elapsed_secs.count(), (double)total_read/(1000*elapsed_secs.count()));
            received = sent = total_read = total_sent = 0;
            receiving = false;
        }

@[end if]@
        usleep(_options.sleep_us);
    }

    return 0;
}
