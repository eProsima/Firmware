# PX4-FastRTPS bridge


This bridge allows communication between a **PX4 Autopilot** and a **Fast RTPS** application through serial ports or
UDP sockets using **CDR serialization**. The goal is to provide a DDS (Data Distribution Service) interface to PX4. This interface is also able to communicate with the upcoming release of ROS (Robot Operating System), ROS2.

DDS is an standard from the OMG (Object Management Group) providing a real-time pub/sub middleware widely used in aerospace, defense and IoT applications, while in Robotics has been adopted as the middleware for ROS2.

![alt text](res/architecture.png)

## Automatic code generation

The support for the functionality is mainly done within three new (automatically generated) code blocks.

-  CDR serialization functions are generated for every uORB topic, e.g. *sensor_combined.msg*:

  ```sh
  void serialize_sensor_combined(const struct sensor_combined_s *input, char *output, uint32_t *length, struct microCDR *microCDRWriter);
  void deserialize_sensor_combined(struct sensor_combined_s *output, char *input, struct microCDR *microCDRReader);
  ```

- The 'Client': Resides on the flight controller and routes messages between uORB and either UART or UDP.

-  The 'Agent': Resides on an offboard computer and routes messages between FastRTPS and either UART or UDP.

These pieces of code are generated within the normal PX4 Firmware generation process. They can also be generated by calling the script **generate_microRTPS_bridge.py** placed in *Tools* folder, see section below.






### Generating the Client and the Agent

**NOTE**: Before continuing follow the instructions in [Fast RTPS installation](https://dev.px4.io/en/setup/fast-rtps-installation.html).

The generation of the code is performed automatically through the normal process of compilation of the PX4 Firmware. We only need to specify the topics we want to send and receive in the **.cmake** file (e.g. *cmake/configs/nuttx_px4fmu-v4_default.cmake* for Pixracer). By default only the sensor_combined and vehicle_command topics are enabled:

```cmake
set(config_rtps_send_topics
   sensor_combined
   # Add new topic...
   )

set(config_rtps_receive_topics
   vehicle_command
    # Add new topic...
   )
```

The Client application will be generated in *build_platform/src/modules/micrortps_bridge/micrortps_client/* folder and the Agent will be created in *src/modules/micrortps_bridge/micrortps_agent/* folder.

It is also is possible to generate and install the code for the Client and the Agent outside the normal process of PX4 generation by executing the python script
**generate_microRTPS_bridge.py** hosted in *Tools* folder.

For example:

  ```sh
  $ cd /path/to/PX4/Firmware
  $ python Tools/generate_microRTPS_bridge.py -s msg/sensor_combined.msg -r msg/vehicle_command.msg
  ```
By default only the sensor_combined and vehicle_command topics are enabled, so the following files should be installed:

  ```sh
src/modules/micrortps_bridge/micrortps_agent
├── build
├── CMakeLists.txt
├── idl
│   ├── sensor_combined_.idl
│   └── vehicle_command_.idl
├── microRTPS_agent.cxx
├── microRTPS_transport.cxx
├── microRTPS_transport.h
├── RtpsTopics.cxx
├── RtpsTopics.h
├── sensor_combined_.cxx
├── sensor_combined_.h
├── sensor_combined_Publisher.cxx
├── sensor_combined_Publisher.h
├── sensor_combined_PubSubTypes.cxx
├── sensor_combined_PubSubTypes.h
├── vehicle_command_.cxx
├── vehicle_command_.h
├── vehicle_command_PubSubTypes.cxx
├── vehicle_command_PubSubTypes.h
├── vehicle_command_Subscriber.cxx
└── vehicle_command_Subscriber.h

build_px4fmu-v4_default/src/modules/micrortps_bridge/micrortps_client/
├── Makefile
├── microRTPS_client.cpp
├── microRTPS_transport.cxx
└── microRTPS_transport.h

```




PX4 Firmware: The Client
-----------------------------------

Start by uploading the firmware:

```sh
$ make px4fmu-v4_default upload # For Pixracer
$ make eagle_default upload # For Snapdragon Flight:
```

Now we can start the Client:

  ```sh
  $ micrortps_client start # By default -t UART -d /dev/ttyACM0 -u 0 -l 10000 -w 1 -b 460800 -p 1

        -t <transport>          [UART|UDP] Default UART
        -d <device>             UART device. Default /dev/ttyACM0
        -u <update_time_ms>     Time in ms for uORB subscribed topics update. Default 0
        -l <loops>              How many iterations will this program have. -1 for infinite. Default 10000
        -w <sleep_time_ms>      Time in ms for which each iteration sleep. Default 1ms
        -b <baudrate>           UART device baudrate. Default 460800
        -p <poll_ms>            Time in ms to poll over UART. Default 1ms
        -r <reception port>     UDP port for receiving. Default 2019
        -s <sending port>       UDP port for sending. Default 2020
  ```

  **NOTE**: If we are working with a USB-serial adapter the **-b** option will be ignored and will be working at maximum speed of the link.

**NOTE**: If the UART port is busy, it's possible that Mavlink applications were using them. In that case, you can stop Mavlink from NuttShell typing:

```sh
$ mavlink stop-all
```



## Fast RTPS: The Agent

If the Agent is running on a Rapsberry Pi, follow the [Extra steps for Raspberry Pi](throughput_test.md) first.

To create the application, compile the code:

  ```sh
  $ cd src/modules/micrortps_bridge/micrortps_agent
  $ mkdir build && cd build
  $ cmake ..
  $ make
  ```

**NOTE**: For crosscompiling for Snapdragon Fligth platform you can see this [link](https://github.com/eProsima/PX4-FastRTPS-PoC-Snapdragon-UDP#how-to-use).

To launch the Agent run:
  ```sh
  $ ./micrortps_agent # by default -t UART -d /dev/ttyACM0 -w 1 -b 460800 -p 1

      -t <transport>          [UART|UDP] Default UART
      -d <device>             UART device. Default /dev/ttyACM0
      -w <sleep_time_us>      Time in us for which each iteration sleep. Default 1ms
      -b <baudrate>           UART device baudrate. Default 460800
      -p <poll_ms>            Time in ms to poll over UART. Default 1ms
      -r <reception port>     UDP port for receiving. Default 2019
      -s <sending port>       UDP port for sending. Default 2020
  ```
  **NOTE**: If we are working with a USB-serial adapter the **-b** option will be ignored and will be working at maximum speed of the link.





## Creating a Listener

Now that we have the Client running on the flight controller and the Agent on the offboard computer, we can create an application to communicate with the flight controller through FastRTPS. The fastrtpsgen script allows us to quickly generate a simple application from a .idl message file. We will use it to create a Listener which subscribes to the sensor_combined topic. The Listener can be run on any computer on the same network as the Agent, but here they will be on the same computer.

```sh
$ cd /path/to/PX4/Firmware/src/modules/micrortps_bridge
$ mkdir micrortps_listener
$ cd micrortps_listener
$ fastrtpsgen -example x64Linux2.6gcc ../micrortps_agent/idl/sensor_combined_.idl
```

This creates a sample subscriber, a publisher and a main-application to run them. To print out the data from the sensor_combined topic we modify the onNewDataMessage-method in sensor_combined_Subscriber.cxx:

```sh
void sensor_combined_Subscriber::SubListener::onNewDataMessage(Subscriber* sub)
{
    // Take data
    sensor_combined_ st;

    if(sub->takeNextData(&st, &m_info))
    {
        if(m_info.sampleKind == ALIVE)
        {
            // Print your structure data here.
            ++n_msg;
            std::cout << "\n\n\n\n\n\n\n\n\n\n";
            std::cout << "Sample received, count=" << n_msg << std::endl;
            std::cout << "=============================" << std::endl;
            std::cout << "gyro_rad: " << st.gyro_rad().at(0);
            std::cout << ", " << st.gyro_rad().at(1);
            std::cout << ", " << st.gyro_rad().at(2) << std::endl;
            std::cout << "gyro_integral_dt: " << st.gyro_integral_dt() << std::endl;
            std::cout << "accelerometer_timestamp_relative: " << st.accelerometer_timestamp_relative() << std::endl;
            std::cout << "accelerometer_m_s2: " << st.accelerometer_m_s2().at(0);
            std::cout << ", " << st.accelerometer_m_s2().at(1);
            std::cout << ", " << st.accelerometer_m_s2().at(2) << std::endl;
            std::cout << "accelerometer_integral_dt: " << st.accelerometer_integral_dt() << std::endl;
            std::cout << "magnetometer_timestamp_relative: " << st.magnetometer_timestamp_relative() << std::endl;
            std::cout << "magnetometer_ga: " << st.magnetometer_ga().at(0);
            std::cout << ", " << st.magnetometer_ga().at(1);
            std::cout << ", " << st.magnetometer_ga().at(2) << std::endl;
            std::cout << "baro_timestamp_relative: " << st.baro_timestamp_relative() << std::endl;
            std::cout << "baro_alt_meter: " << st.baro_alt_meter() << std::endl;
            std::cout << "baro_temp_celcius: " << st.baro_temp_celcius() << std::endl;

        }
    }
}

```

Now build and run the Listener:

```sh
$ make -f makefile_x64Linux2.6gcc
$ bin/*/sensor_combined_PublisherSubscriber subscriber
```

Now you should see the alititude being printed out by the Listener

```sh
Sample received, count=10119
Received sensor_combined data
=============================
gyro_rad: -0.0103228, 0.0140477, 0.000319406
gyro_integral_dt: 0.004
accelerometer_timestamp_relative: 0
accelerometer_m_s2: -2.82708, -6.34799, -7.41101
accelerometer_integral_dt: 0.004
magnetometer_timestamp_relative: -10210
magnetometer_ga: 0.60171, 0.0405879, -0.040995
baro_timestamp_relative: -17469
baro_alt_meter: 368.647
baro_temp_celcius: 43.93
```

If the Listener does not print anything, make sure the Client is running. By default the Client runs for 10000 and than stops, to run the Client continuously run
```sh
$ micrortps_client start -l -1 
```

Please click [Throughput test](throughput_test.md) to see an example of creating new messages and measuring throughput.





## Troubleshooting

**Compile errors when uploading the firmware**

It is possible to generate and install the code for the Client and the Agent outside the normal process of PX4 code generation by running the script, Tools/generate_microRTPS_bridge.py.

```sh
$ cd /path/to/PX4/Firmware
$ python Tools/generate_microRTPS_bridge.py -h
usage: generate_microRTPS_bridge.py [-h] [-s *.msg [*.msg ...]]
                                    [-r *.msg [*.msg ...]] [-a] [-c]
                                    [-t MSGDIR] [-o AGENTDIR] [-u CLIENTDIR]
                                    [-f FASTRTPSGEN]

optional arguments:
  -h, --help            show this help message and exit
  -s *.msg [*.msg ...], --send *.msg [*.msg ...]
                        Topics to be sended
  -r *.msg [*.msg ...], --receive *.msg [*.msg ...]
                        Topics to be received
  -a, --agent           Flag for generate the agent, by default is true if -c
                        is not specified
  -c, --client          Flag for generate the client, by default is true if -a
                        is not specified
  -t MSGDIR, --topic-msg-dir MSGDIR
                        Topics message dir, by default msg/
  -o AGENTDIR, --agent-outdir AGENTDIR
                        Agent output dir, by default
                        src/modules/micrortps_bridge/micrortps_agent
  -u CLIENTDIR, --client-outdir CLIENTDIR
                        Client output dir, by default
                        src/modules/micrortps_bridge/micrortps_client
  -f FASTRTPSGEN, --fastrtpsgen-dir FASTRTPSGEN
                        fastrtpsgen installation dir, by default /bin
  --no-delete           Do not delete dir tree output dir(s)
```



**UART port is busy, or the Agent prints out '(↓↓ 6)'** 

Mavlink is using the same port as the Agent. Choose a different port or stop Mavlink from NuttShell:

```sh
$ mavlink stop-all
```

**The Client keeps printing => `Writing error '11'`**

Make sure the Agent is running and the that both are referencing the correct port.

**System can't find fastrtpsgen**

If Fast RTPS is not installed in the default path you need to specify the directory of installation of fastrtpsgen setting the environment variable *FASTRTPSGEN_DIR*:
```sh
$ export FASTRTPSGEN_DIR=/path//to/fastrtps/install/folder/bin
```


### Extra steps for Raspberry Pi 
Normally, for UART transport it's necessary set up the UART port in the Raspberry Pi. To enable the serial port available on Raspberry Pi connector:

1. Make sure the userid (default is pi) is a member of the dialout group:

  ```sh
  $ groups pi
  $ sudo usermod -a -G dialout pi
  ```

2. You need to stop the already running on the GPIO serial console:

  ```sh
  $ sudo raspi-config
  ```

Go to *Interfacing options > Serial*, NO to *Would you like a login shell to be accessible over serial?*, valid and reboot.

3. Check UART in kernel:

  ```sh
  $ sudo vi /boot/config.txt
  ```

And enable UART setting *enable_uart=1*.